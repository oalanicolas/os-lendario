// @ts-nocheck
// PRD Studio - Export Functions
// Generates exports in different formats for various tools
// Type mismatches deferred to Story 0.2.1 - PRD Studio Type System Refactor

import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import type { PRDProject, EpicData, StoryData } from '../../types/prd';

// =============================================================================
// TYPES
// =============================================================================

export type ExportFormat = 'lovable' | 'claude_code' | 'generic';

export interface ExportFile {
  path: string;
  content: string;
}

export interface ExportMetadata {
  generatedAt: string;
  projectName: string;
  projectSlug: string;
  totalEpics: number;
  totalStories: number;
  format: ExportFormat;
}

export interface ExportResult {
  content?: string;
  files?: ExportFile[];
  metadata: ExportMetadata;
}

export interface ExportOption {
  key: ExportFormat;
  label: string;
  description: string;
  icon: string;
  status: 'available' | 'coming_soon';
  outputFormat: 'markdown' | 'zip' | 'json';
}

// =============================================================================
// CONSTANTS
// =============================================================================

export const EXPORT_OPTIONS: ExportOption[] = [
  {
    key: 'lovable',
    label: 'Lovable',
    description: 'Prompt otimizado para Lovable.dev - cria apps completos a partir do PRD',
    icon: 'heart',
    status: 'available',
    outputFormat: 'markdown',
  },
  {
    key: 'claude_code',
    label: 'Claude Code',
    description: 'Estrutura de arquivos para usar com Claude Code CLI',
    icon: 'terminal',
    status: 'available',
    outputFormat: 'zip',
  },
  {
    key: 'generic',
    label: 'Markdown',
    description: 'PRD completo em Markdown - compatível com qualquer ferramenta',
    icon: 'file-text',
    status: 'available',
    outputFormat: 'markdown',
  },
];

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

function formatDate(date: Date = new Date()): string {
  return date.toISOString().split('T')[0];
}

function createMetadata(
  project: PRDProject,
  format: ExportFormat,
  epics: EpicData[],
  stories: StoryData[]
): ExportMetadata {
  return {
    generatedAt: new Date().toISOString(),
    projectName: project.name,
    projectSlug: project.slug,
    totalEpics: epics.length,
    totalStories: stories.length,
    format,
  };
}

function formatStoriesForMarkdown(stories: StoryData[], epicId: string): string {
  const epicStories = stories.filter((s) => s.epic_id === epicId);
  if (epicStories.length === 0) return '_Nenhuma story definida_';

  return epicStories
    .map((story, index) => {
      const acList = story.acceptanceCriteria.map((ac) => `  - ${ac}`).join('\n');

      return `
#### ${index + 1}. ${story.title}

**User Story:** ${story.userStory}

**Complexidade:** ${story.complexity}

**Critérios de Aceite:**
${acList}
`;
    })
    .join('\n');
}

// =============================================================================
// LOVABLE EXPORT
// =============================================================================

export function generateLovableExport(
  project: PRDProject,
  epics: EpicData[],
  stories: StoryData[]
): ExportResult {
  const brief = project.project_metadata?.brief?.structure;
  const prdDoc = project.project_metadata?.prdDocument?.document;

  const features = epics
    .map((epic, i) => `${i + 1}. **${epic.title}**: ${epic.description}`)
    .join('\n');

  const storyList = stories.map((s) => `- ${s.title}: ${s.userStory}`).join('\n');

  const content = `# ${project.name}

## Vision
${brief?.solution || prdDoc?.scope?.content || 'A definir'}

## Target Users
${brief?.targetAudience || 'Usuários gerais'}

## Problem Statement
${brief?.problem || prdDoc?.objectives?.content || 'A definir'}

## Core Features
${features || '_Nenhuma feature definida_'}

## Key Differentials
${brief?.differentials?.map((d) => `- ${d}`).join('\n') || '- A definir'}

## Design Guidelines
- Modern, clean interface
- Mobile-first approach
- Accessibility compliant (WCAG 2.1)
- Dark mode support
${prdDoc?.designDecisions?.content ? `\n### Design Decisions\n${prdDoc.designDecisions.content}` : ''}

## Technical Requirements
${prdDoc?.requirements?.content || '- React/Next.js\n- TypeScript\n- Tailwind CSS'}

## User Stories Overview
${storyList || '_Nenhuma story definida_'}

## Success Metrics
${brief?.successMetrics?.map((m) => `- ${m}`).join('\n') || '- A definir'}

---

> Generated by PRD Studio on ${formatDate()}
> Project: ${project.name} (${project.slug})
`;

  return {
    content,
    metadata: createMetadata(project, 'lovable', epics, stories),
  };
}

// =============================================================================
// CLAUDE CODE EXPORT
// =============================================================================

export function generateClaudeExport(
  project: PRDProject,
  epics: EpicData[],
  stories: StoryData[]
): ExportResult {
  const brief = project.project_metadata?.brief?.structure;
  const prdDoc = project.project_metadata?.prdDocument?.document;
  const files: ExportFile[] = [];

  // CLAUDE.md - Main project instructions
  const claudeMd = `# ${project.name}

## Project Overview
${brief?.solution || prdDoc?.scope?.content || 'A definir'}

## Problem Being Solved
${brief?.problem || prdDoc?.objectives?.content || 'A definir'}

## Target Audience
${brief?.targetAudience || 'Usuários gerais'}

## Development Guidelines

### Code Standards
- Use TypeScript with strict mode
- Follow existing code patterns
- Write comprehensive error handling
- Add unit tests for new functionality

### Architecture
${prdDoc?.architecture?.content || '- Follow clean architecture principles\n- Keep components modular\n- Use dependency injection where appropriate'}

## Story-Driven Development
1. Work from stories in \`docs/stories/\`
2. Update progress checkboxes as tasks complete
3. Follow acceptance criteria exactly
4. Run tests before marking complete

## Key Files
- \`docs/stories/\` - Development stories
- \`docs/architecture.md\` - System architecture

---
*Generated by PRD Studio on ${formatDate()}*
`;

  files.push({ path: '.claude/CLAUDE.md', content: claudeMd });

  // architecture.md
  const architectureMd = `# ${project.name} - Architecture

## System Overview
${prdDoc?.architecture?.content || 'A definir'}

## Technical Stack
${prdDoc?.requirements?.content || '- To be defined'}

## Design Decisions
${prdDoc?.designDecisions?.content || 'A definir'}

## Epics Overview

${epics
  .map(
    (epic, i) => `### Epic ${i + 1}: ${epic.title}
${epic.description}
- Stories: ${stories.filter((s) => s.epic_id === epic.id).length}
`
  )
  .join('\n')}

---
*Generated by PRD Studio*
`;

  files.push({ path: 'docs/architecture.md', content: architectureMd });

  // Individual story files
  epics.forEach((epic, epicIndex) => {
    const epicStories = stories.filter((s) => s.epic_id === epic.id);

    epicStories.forEach((story, storyIndex) => {
      const storyNumber = `${epicIndex + 1}.${storyIndex + 1}`;
      const storyMd = `# Story ${storyNumber}: ${story.title}

**Epic:** ${epicIndex + 1} - ${epic.title}
**Status:** Draft
**Complexidade:** ${story.complexity}

---

## User Story

${story.userStory}

---

## Acceptance Criteria

${story.acceptanceCriteria.map((ac) => `- [ ] ${ac}`).join('\n')}

---

## Tasks

- [ ] Implementar funcionalidade
- [ ] Adicionar testes
- [ ] Revisar código
- [ ] Atualizar documentação

---

## Story Points

**Estimativa:** ${story.complexity === 'P' ? '1' : story.complexity === 'M' ? '3' : '5'} pontos
`;

      files.push({
        path: `docs/stories/${storyNumber}.story.md`,
        content: storyMd,
      });
    });
  });

  // README for the export
  const readmeMd = `# ${project.name} - PRD Export

This export was generated by PRD Studio for use with Claude Code.

## Structure

\`\`\`
.claude/
  CLAUDE.md          # Project instructions for Claude
docs/
  architecture.md    # System architecture
  stories/           # Development stories
    1.1.story.md
    1.2.story.md
    ...
\`\`\`

## Usage

1. Extract this ZIP to your project root
2. Open the project with Claude Code
3. Claude will read the instructions from \`.claude/CLAUDE.md\`
4. Start implementing stories from \`docs/stories/\`

## Stats

- Epics: ${epics.length}
- Stories: ${stories.length}
- Generated: ${formatDate()}

---
*Generated by PRD Studio*
`;

  files.push({ path: 'README.md', content: readmeMd });

  return {
    files,
    metadata: createMetadata(project, 'claude_code', epics, stories),
  };
}

// =============================================================================
// GENERIC MARKDOWN EXPORT
// =============================================================================

export function generateGenericExport(
  project: PRDProject,
  epics: EpicData[],
  stories: StoryData[]
): ExportResult {
  const brief = project.project_metadata?.brief?.structure;
  const prdDoc = project.project_metadata?.prdDocument?.document;

  // Generate TOC
  const tocItems = [
    '1. [Executive Summary](#1-executive-summary)',
    '2. [Objectives](#2-objectives)',
    '3. [Requirements](#3-requirements)',
    '4. [Architecture](#4-architecture)',
    '5. [Epics & Stories](#5-epics--stories)',
    '6. [Appendix](#6-appendix)',
  ];

  const epicsSection = epics
    .map((epic, i) => {
      const epicStories = formatStoriesForMarkdown(stories, epic.id);
      return `
### 5.${i + 1}. ${epic.title}

${epic.description}

**Stories:**
${epicStories}
`;
    })
    .join('\n');

  const content = `# ${project.name} - PRD

> **Generated:** ${formatDate()}
> **Version:** 1.0
> **Status:** ${project.status}

---

## Table of Contents

${tocItems.join('\n')}

---

## 1. Executive Summary

### Problem
${brief?.problem || prdDoc?.objectives?.content || '_A definir_'}

### Solution
${brief?.solution || prdDoc?.scope?.content || '_A definir_'}

### Target Audience
${brief?.targetAudience || '_A definir_'}

### Key Differentials
${brief?.differentials?.map((d) => `- ${d}`).join('\n') || '_A definir_'}

---

## 2. Objectives

${prdDoc?.objectives?.content || brief?.solution || '_A definir_'}

### Success Metrics
${brief?.successMetrics?.map((m) => `- ${m}`).join('\n') || '_A definir_'}

---

## 3. Requirements

### 3.1 Functional Requirements
${prdDoc?.requirements?.content || '_A definir_'}

### 3.2 Non-Functional Requirements
${prdDoc?.scope?.content || '_A definir_'}

### 3.3 Risks & Mitigations
${brief?.risks?.map((r) => `- ${r}`).join('\n') || '_A definir_'}

---

## 4. Architecture

${prdDoc?.architecture?.content || '_A definir_'}

### Design Decisions
${prdDoc?.designDecisions?.content || '_A definir_'}

---

## 5. Epics & Stories

**Total Epics:** ${epics.length}
**Total Stories:** ${stories.length}

${epicsSection || '_Nenhum épico definido_'}

---

## 6. Appendix

### Project Metadata
- **Created:** ${project.created_at}
- **Last Updated:** ${project.updated_at}
- **Slug:** ${project.slug}

### Export Information
- **Format:** Generic Markdown
- **Generated by:** PRD Studio
- **Date:** ${formatDate()}

---

*This document was generated automatically by PRD Studio.*
`;

  return {
    content,
    metadata: createMetadata(project, 'generic', epics, stories),
  };
}

// =============================================================================
// MAIN EXPORT FUNCTION
// =============================================================================

export function generateExport(
  format: ExportFormat,
  project: PRDProject,
  epics: EpicData[],
  stories: StoryData[]
): ExportResult {
  switch (format) {
    case 'lovable':
      return generateLovableExport(project, epics, stories);
    case 'claude_code':
      return generateClaudeExport(project, epics, stories);
    case 'generic':
      return generateGenericExport(project, epics, stories);
    default:
      throw new Error(`Unknown export format: ${format}`);
  }
}

// =============================================================================
// DOWNLOAD FUNCTIONS
// =============================================================================

/**
 * Download files as a ZIP archive
 * @param files - Array of files to include in the ZIP
 * @param filename - Name of the ZIP file (without extension)
 */
export async function downloadAsZip(files: ExportFile[], filename: string): Promise<void> {
  const zip = new JSZip();

  files.forEach((file) => {
    zip.file(file.path, file.content);
  });

  const blob = await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 },
  });

  saveAs(blob, `${filename}.zip`);
}

/**
 * Download content as a Markdown file
 * @param content - Markdown content
 * @param filename - Name of the file (without extension)
 */
export function downloadAsMarkdown(content: string, filename: string): void {
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
  saveAs(blob, `${filename}.md`);
}

/**
 * Download export result based on format
 * @param result - Export result
 * @param format - Export format
 * @param projectSlug - Project slug for filename
 */
export async function downloadExport(
  result: ExportResult,
  format: ExportFormat,
  projectSlug: string
): Promise<void> {
  const dateStr = new Date().toISOString().split('T')[0];
  const filename = `${projectSlug}-prd-${dateStr}`;

  if (format === 'claude_code' && result.files) {
    await downloadAsZip(result.files, filename);
  } else if (result.content) {
    downloadAsMarkdown(result.content, filename);
  }
}
